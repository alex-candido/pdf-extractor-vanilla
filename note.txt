Com Typescript, faça uma função findIntervalQuestion, onde vai receber como parâmetro um array de objects [{str: string, hasEOL: boolean, dir: string, width: number, height: number, etc..}, etc..], internamente o objeto representa uma word "str", o problema é que nessa lista as words quando separadas são questions, ou seja um intervalo de questions, nesse caso, preciso encontrar as words/objects que iniciam com "QUESTÃO", além disso, o intervalo do array de objects termina antes de ser encontrado a próxima word/object igual a "QUESTÃO".

	Ou seja, o intervalo corresponde ao encontro da word/object igual a "QUESTÃO", mais uma sequencia de words/object que terminam antes de encontrar a próxima word/object igual a "QUESTÃO". Portanto, esse array de intervalos quando separado deve ser armazenado separadamente em outro array de intervalos, por exemplo, seria um array const questions_interval = [{question_interval: [{ str: "string", hasEOL: "true" },{ str: "string", hasEOL: "true" },etc...]},{question_interval: [{ str: "string", hasEOL: "true" },{ str: "string", hasEOL: "true" },etc...]}, etc...], onde cada question_interval possui um array de words/objects, sendo assim representado um array de questions.

	Nessa segunda etapa, depois de obter questions_interval, crie uma função findIntervalAlternativesOfQuestions que vai receber como parêmetro questions_interval, onde irei verificar em cada question_interval, ou seja, agora vou verificar os word/object internos da question_interval. O problema é em que cada question_interval se processado possui alternatives, ou seja, topics de uma question.

Por exemplo, se for analisar cada word/object de cada question_interval separadamente, as alternatives começam com a sequencia de word/object representado por { str: "" } igual "A" e "A", "B" e "B", "C" e "C", "D" e "D", "E" e "E". Nesse caso, preciso primeiro fazer uma separação alternatives_interval, que é indentificar em cada word/object de question_interval, nas word/object que se repetirem { str: "A" } seguido de { str: "A" }, no processo, o intervalo de question_interval que corresponder a alternativa "A" quando termina antes de ser encontrado o próximo alternative_interval, seria armazenado separadamente como alternative_interval "A" da question_interval atual, e o próximo seria a alternative "B" que se repete na segunda verificação depois de "A" seguindo a ordem {str: "B"} seguido de {str: "B"}, e assim sucessivamente os intervalos de objetos para CC, DD, EE. Tem que se atentar que, a question_interval possue também o words_base que seria o os words/object que exitem antes das alternatives_interval, isso em cada question_intevral, portanto, antes de ser encontrado e verificado a primeira alternative_interval, as word/object que vinherem antes do primeiro alternative_interval, seriam armazenadas no array base_words, ou seja, na verificação cada word/object que não corresponder ao primeiro alternative_interval seria separadas e salvas em base_words e cada alternative_interval extraido de question_interval deve ser armazenado em outro array chamado alternatives_interval. Portando, na função quando verificado separadamente cada question_interval do parâmetro questions_interval, e dentro da question_interval é obtido cada alternative_interval e armazenado em alternatives_interval, tudo que vem antes das alternatives_interval é armazenado em words_base, então é retornaro as word_base e alternatines_interval de cada question interval.

	Nesse sentido, question_interval, possui um alternatives_interval que é uma lista de alternative_interval, e um words_base que é uma lista de words/object, o resultado retornado da fução findIntervalAlternativesOfQuestions, seria igual a const questions_interval teria uma list de question_inteval e question_inteval teria um objeto contendo agora words_base que é uma lista de word/objects, e alternatives_inteval que é uma lista de alternative_interval. Semanticamente falando, teriamos uma lista de questões com cada questao tendo um base de text e uma lista de alternativas.
